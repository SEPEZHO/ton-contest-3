;; #include "imports/stdlib.fc";
(int) tlena(tuple t) asm "TLEN";
forall X -> X tpopa(tuple t) asm "TPOP";

{-
  Contract receives internal message with text comment (https://ton.org/docs/develop/smart-contracts/guidelines/internal-messages)
  which contains arithmetic expression containing integer numbers in decimal representation and operations (+-*/).
  All values (including intermediate) fit 256 bit. Contract should respond (coins = 0, mode = 64) with correct
  answer encoded as text comment back.
  It is guaranteed that all tests contain a valid algebraic equations.
  Division result should be rounded down. It is guaranteed that tests do not contain division by zero.
-}


(int) getPrecedence(int ch) {
  if ((ch == 43) | (ch == 45)){
    return (1);
  }
  if ((ch == 42) | (ch == 47)) {
    return (2);
  }
  return (0);
}

(tuple) revert_tuple(tuple tup) {
  var (int tuple_length) = tlena(tup);
  int counter = 0;
  tuple reverted_tuple = empty_tuple();
  while (counter < tuple_length) {
    var (int v) = tup~tpopa();
    reverted_tuple~tpush(v);
    counter += 1;
  }
  return reverted_tuple;
}

(tuple) revert_ls_tuple(tuple tup) {
  tuple reverted_tuple = null();
  while (~(null?(tup))){
    reverted_tuple = cons(tup~list_next(), reverted_tuple);
  }
  return reverted_tuple;
}

(int) ls_tlen(tuple tup) {
  int i = 0;
  while (~(null?(tup))){
    tup~list_next();
    i += 1;
  }
  return i;
}

(tuple) tuple_rm_item(tuple cacheNumbers, int place){
  tuple cacheBetweenOperators = empty_tuple();
  var (int len) = tlena(cacheNumbers);
  int c = 0;
  while (c < len) {
    int action = cacheNumbers.at(c);
    if (c == place){
    } else {
      cacheBetweenOperators~tpush(action);
    }
    c += 1;  
  }
  return (cacheBetweenOperators);
}

(int) calcWithOperator(int ch, int a, int b){
  int res = 0;
  if (ch == 43) { ;; +
    res = a + b;
  }
  if (ch == 45){ ;; -
    res = a - b;
  }
  if (ch == 42){ ;; *
    res = a * b;
  }
  if (ch == 47){ ;; /
    res = a / b;
  }
  ;; 40 - (
  ;; 41 - )
  return res;
}

(int) default_pow(int num, int pow) {
  int result = 1;
  int counter = 0;
  while (counter < pow) {
    result *= num;
    counter += 1;
  }
  return result;
}


(int) make_reverse_calculating(tuple cacheBetweenOperators) {
  var (int r) = tlena(cacheBetweenOperators);
  int index = -1;
  int c = 0;
  int sum = 0;
  while (c < r) {
    index = c;
    var (int q) = cacheBetweenOperators~tpopa();
    var rqwe = default_pow(10, index);
    sum += (q * rqwe);
    c += 1;
  }
  return sum;
}

() sendMessage(slice add, int op, int query_id, int res) impure {
  ;;~dump(888999);
  cell mssage = begin_cell()
    .store_uint(0x18, 6)
    .store_slice(add)
    .store_coins(0)
    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
    .store_uint(query_id, 64)
    .store_uint(res, 64)
    .end_cell();
  send_raw_message(mssage, 64);
}

;; testable
() recv_internal (cell in_msg, slice in_msg_body) {
  slice cs = in_msg.begin_parse();
  int flags = cs~load_uint(4);
  slice sender_address = cs~load_msg_addr();
  int op = in_msg_body~load_uint(32);
  int query_id = in_msg_body~load_uint(64);
  
   ;;~dump(op);
   ;;~dump(query_id);

  int count_of_iterations = begin_cell().store_slice(in_msg_body).builder_bits() / 8;
  
  if (((begin_cell().store_slice(in_msg_body).builder_bits() / 8) == 0)){
    if (in_msg_body.slice_refs_empty?()){
    } else {
      cell ref = in_msg_body~load_ref();
      in_msg_body = ref.begin_parse();
      count_of_iterations = begin_cell().store_slice(in_msg_body).builder_bits() / 8;
    }
  }

  int isLastUintParsed = 0;
  int dohuya = 38411211277;
  int ch = 0;
  tuple arrA = null();
  tuple arrN = null();
  tuple stack = null();
  int i = 0;
  int iLast = 0;
   ;;~dump(op);

  while (((begin_cell().store_slice(in_msg_body).builder_bits() / 8) >= 1) | isLastUintParsed != 0){
    if (isLastUintParsed == 0){
      ch = in_msg_body~load_uint(8);
    } else {
      ch = isLastUintParsed;
      isLastUintParsed = 0;
    }
    ;;~dump(ch);
    if ((ch == 43) | (ch == 45) | (ch == 42) | (ch == 47)) {
      if (ch == 45) {
        slice adf = in_msg_body;
        int next = adf~load_uint(8);
        var (int stack_length) = ls_tlen(stack);
        if (i == 0){
          if ((next != 43) & (next != 45) & (next != 42) & (next != 47) & (next != 40) & (next != 41)) {
            in_msg_body~load_uint(8);
            int ifNextNum = 1;
            tuple cacheBetweenOperators = empty_tuple();
            while (ifNextNum == 1){
              if ((next != 43) & (next != 45) & (next != 42) & (next != 47) & (next != 40) & (next != 41)) {
                cacheBetweenOperators~tpush(next - 48);
                if ((begin_cell().store_slice(in_msg_body).builder_bits() / 8) != 0){
                  next = in_msg_body~load_uint(8);
                } else {
                  int final = make_reverse_calculating(cacheBetweenOperators);
                  cacheBetweenOperators = empty_tuple();
                  arrA = cons(dohuya, arrA);
                  arrN = cons(0 - final, arrN);
                  ifNextNum = 0;
                  if (in_msg_body.slice_refs_empty?()){
                    isLastUintParsed = next;
                  }
                }
              } else {
                int final = make_reverse_calculating(cacheBetweenOperators);
                cacheBetweenOperators = empty_tuple();
                arrA = cons(dohuya, arrA);
                arrN = cons(0 - final, arrN);
                ifNextNum = 0;
                if (in_msg_body.slice_refs_empty?()){
                  isLastUintParsed = next;
                }
              }
            }
          }
        } else {
          if (iLast == 40){
              if ((next != 43) & (next != 45) & (next != 42) & (next != 47) & (next != 40) & (next != 41)) {
                in_msg_body~load_uint(8);
                int ifNextNum = 1;
                tuple cacheBetweenOperators = empty_tuple();
                while (ifNextNum == 1){
                  if ((next != 43) & (next != 45) & (next != 42) & (next != 47) & (next != 40) & (next != 41)) {
                    cacheBetweenOperators~tpush(next - 48);
                    if ((begin_cell().store_slice(in_msg_body).builder_bits() / 8) != 0){
                      next = in_msg_body~load_uint(8);
                    } else {
                      int final = make_reverse_calculating(cacheBetweenOperators);
                      cacheBetweenOperators = empty_tuple();
                      arrA = cons(dohuya, arrA);
                      arrN = cons(0 - final, arrN);
                      ifNextNum = 0;
                      if (in_msg_body.slice_refs_empty?()){
                        isLastUintParsed = next;
                      }
                    }
                  } else {
                    int final = make_reverse_calculating(cacheBetweenOperators);
                    cacheBetweenOperators = empty_tuple();
                    arrA = cons(dohuya, arrA);
                    arrN = cons(0 - final, arrN);
                    ifNextNum = 0;
                    if (in_msg_body.slice_refs_empty?()){
                      isLastUintParsed = next;
                    }
                  }
                }
              ;; }
            }
          }
        }
      }
      var (int stack_length) = ls_tlen(stack);
      if (stack_length != 0){
        int aaa = 0;
        while (aaa == 0) {
          stack_length = ls_tlen(stack);
          if (stack_length != 0){
            if ((car(stack)) != 40) & (getPrecedence(ch) <= getPrecedence(car(stack))){
              int za = car(stack);
              if ((za != 43) & (za != 45) & (za != 42) & (za != 47) & (za != 40) & (za != 41)) {
                arrA = cons(dohuya, arrA);
                arrN = cons(za, arrN);
              } else {
                arrA = cons(za, arrA);
                arrN = cons(dohuya, arrN);
              }
              stack~list_next();
              stack_length = ls_tlen(stack);
            } else {
              aaa = 1;
            }
          } else {
            aaa = 1;
          }
        }
      }
      stack = cons(ch, stack);
    } else {
      if (ch == 40){
        stack = cons(ch, stack);
      } else {
        if (ch == 41){
          int stack_length = ls_tlen(stack);
          while ((stack_length != 0)) {
            if (car(stack) != 40){
              int za = car(stack);
              if ((za != 43) & (za != 45) & (za != 42) & (za != 47) & (za != 40) & (za != 41)) {
                arrA = cons(dohuya, arrA);
                arrN = cons(za, arrN);
              } else {
                arrA = cons(za, arrA);
                arrN = cons(dohuya, arrN);
              }
              stack~list_next();
              stack_length = ls_tlen(stack);
            } else {
              stack~list_next();
              stack_length = ls_tlen(stack);
            }
          }
        } else {
          if ((ch != 43) & (ch != 45) & (ch != 42) & (ch != 47) & (ch != 40) & (ch != 41)) {
            int ifNextNum = 1;
            tuple cacheBetweenOperators = empty_tuple();
            while (ifNextNum == 1){
              ;;  ;;   ;;~dumpp(ch);
              if ((ch != 43) & (ch != 45) & (ch != 42) & (ch != 47) & (ch != 40) & (ch != 41)) {
                cacheBetweenOperators~tpush(ch - 48);
                if ((begin_cell().store_slice(in_msg_body).builder_bits() / 8) != 0){
                  ch = in_msg_body~load_uint(8);
                } else {
                  ifNextNum = 0;
                  int final = make_reverse_calculating(cacheBetweenOperators);
                  cacheBetweenOperators = empty_tuple();
                  arrA = cons(dohuya, arrA);
                  arrN = cons(final, arrN);
                  ;; isLastUintParsed = ch;
                }
              } else {
                ifNextNum = 0;
                int final = make_reverse_calculating(cacheBetweenOperators);
                cacheBetweenOperators = empty_tuple();
                arrA = cons(dohuya, arrA);
                arrN = cons(final, arrN);
                isLastUintParsed = ch;
              }
            }
          }
        }
      }
    }
    if (((begin_cell().store_slice(in_msg_body).builder_bits() / 8) == 0)){
      if (in_msg_body.slice_refs_empty?()){
      } else {
        cell ref = in_msg_body~load_ref();
        in_msg_body = ref.begin_parse();
        count_of_iterations = begin_cell().store_slice(in_msg_body).builder_bits() / 8;
      }
    }
    i += 1;
    iLast = ch;
  }
   ;;   ;;~dump(revert_ls_tuple(arrA));
   ;;   ;;~dump(revert_ls_tuple(arrN));
  var (int stack_length) = ls_tlen(stack);
  while (stack_length != 0) {
    int za = car(stack);
    if ((za != 43) & (za != 45) & (za != 42) & (za != 47) & (za != 40) & (za != 41)) {
      arrA = cons(dohuya, arrA);
      arrN = cons(za, arrN);
    } else {
      arrA = cons(za, arrA);
      arrN = cons(dohuya, arrN);
    }
    stack~list_next();
    stack_length = ls_tlen(stack);
  }
  var (int output_length) = ls_tlen(arrN);
  stack = null();
  int chA = 0;
  int chN = 0;
  int ii = 0;
  arrA = revert_ls_tuple(arrA);
  arrN = revert_ls_tuple(arrN);
  while (ii < output_length) {
    chA = arrA~list_next();
    chN = arrN~list_next();
    if (chA == dohuya){
      stack = cons(chN, stack);
    } else {
      if ((chA == 43) | (chA == 45) | (chA == 42) | (chA == 47)) {
        int b = stack~list_next();
        int a = stack~list_next();
        int val = calcWithOperator(chA, a, b);
        stack = cons(val, stack);
      }
    }
    ii += 1;
  }

     ;;~dump(car(stack));
  sendMessage(sender_address, op, query_id, car(stack));
  ;; return (output);
}